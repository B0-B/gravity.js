<!DOCTYPE html>
<html>
    <head>
        
    </head>
    <body>
        <script>

            /* Tuning */
            blur_factor = 5.0;              // unit-less
            dt = 10                         // years
            g_scale_factor = 10e+0;
            galaxy_size = 50000;            // light years
            imf_alpha = 2.35;
            plot_scale = 0.005;
            plummer_bulge = 3000;            // light years
            star_color = [
                '#c210bc', 
                '#f71a0a', 
                '#f3f70a', 
                '#f7f7da', 
                '#94fff3'];
            star_mass_max = 2;
            star_mass_min = .1;
            star_scale_factor = 1;          // unit-less
            time_delay_ms = 0;              // milliseconds
            v_start = 10;
            N = 300;                        // unit-less
            T = 10e+9;                      // years

            /* All parameters are in SI-units */
            const   m_sun = 1.989e+30,
                    G = 6.67430e-11,
                    ly = 9.46e+15,
                    pc = 3.086e+19,
                    yr = 31.536e+6;
            
            /* Canvas UI */
            const [w,h] = [window.innerWidth,window.innerHeight];
            const center = [Math.floor(w/2),Math.floor(h/2)];
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            document.body.appendChild(canvas);
            ctx.canvas.width=w;ctx.canvas.height=h;document.body.style.background='#04050d';
            async function cl(){ctx.clearRect(0,0,canvas.width,canvas.height)}
            function draw(x,y,scale,col='#000'){
                ctx.fillStyle=col;
                
                ctx.beginPath();
                ctx.arc(Math.floor(x+center[0]),Math.floor(y+center[1]), scale*star_scale_factor, 0, 2 * Math.PI);
                ctx.fill();

                ctx.shadowBlur = scale*blur_factor;
	            ctx.shadowColor = col;
                ctx.beginPath();
                ctx.arc(Math.floor(x+center[0]),Math.floor(y+center[1]), scale*star_scale_factor, 0, 2 * Math.PI);
                ctx.fill();
            }

            /* Vectors & Gravity */
            function dist(v,w){return [w[0]-v[0],w[1]-v[1]]}
            function dot(v,w){return v[0]*w[0]+v[1]*w[1]}
            function mag(v){return Math.sqrt(dot(v,v))}
            function a_plummer(v,w,m,a){
                // star at vector w acts on star described by v
                r = dist(v,w);
                c = g_scale_factor*G*m/((dot(r,r)+a**2)**(1.5));
                return [c*r[0],c*r[1]]
            }

            /* Sampling */
            function u(){return Math.random()};
            function boxMuller(){x=u();A=Math.sqrt(-2*Math.log(u()));return[A*Math.cos(2*Math.PI*x),A*Math.sin(2*Math.PI*x)]}
            function star(){
                const[x,y]=boxMuller();
                const[v,w]=boxMuller();
                const col = star_color[Math.floor(u()*5)];
                const m = u()*(star_mass_max-star_mass_min)+star_mass_min;
                return [m,x*galaxy_size*ly,y*galaxy_size*ly,v*v_start,w*v_start,col]}
            
            // algorithm
            S = {}
            function init () {for (i=0;i<N;i++){S[i] = star()}}
            async function plot () {for (s in S){draw(Math.floor(plot_scale*S[s][1]/ly),Math.floor(plot_scale*S[s][2]/ly),S[s][0],S[s][5])}}
            async function leapFrog () {
                t=0;
                delta_t = dt*ly;
                while (t<T) {
                    await cl();
                    await plot();
                    for (p1 in S) {
                        // determine net acceleration
                        a = [0,0];
                        for (p2 in S) {
                            if (p2 == p1) {continue}
                            const f = a_plummer(S[p1].slice(1,3),S[p2].slice(1,3),S[p2][0]*m_sun,plummer_bulge*ly)
                            a[0] = a[0] + f[0];
                            a[1] = a[1] + f[1];
                        }
                        const[a_x,a_y]=[a[0]*delta_t*.5,a[1]*delta_t*.5];
                        // kick
                        v_half_x = S[p1][3] + a_x;
                        v_half_y = S[p1][4] + a_y;
                        // drift
                        S[p1][1] = S[p1][1] + v_half_x*delta_t;
                        S[p1][2] = S[p1][2] + v_half_y*delta_t;
                        // kick
                        S[p1][3] = v_half_x + a_x;
                        S[p1][4] = v_half_y + a_y;
                    }
                    await new Promise(r => setTimeout(r, time_delay_ms));
                    t += dt;
                }
            }
            // start
            init();leapFrog();

        </script>
    </body>
</html>